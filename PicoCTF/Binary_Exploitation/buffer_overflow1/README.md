From intial understanding and look at source code, we can buffer overflow as there is a use of the gets command.


This is easy enough to do, simply overflow that buffer with a string larger than its intended destination:
'a' * 33 -> greater than buffer size of 32, which causes a buffer overflow and a seg fault.

Increasing our overflow by 1 byte each time (+ 4a's) eventually leads to us requiring 44 a's, then the next 4 bytes are the return address. In order to control the return address we need to insert the hexadecimal equivalent of the 'win' function
in memory into the string after the 40 a's. Research shows using 'readelf' was the simplest way.

Using readelf with -s, scrolling to #63 gives us the hexadecimal value of the win function. 
It still wont work however as we cant just take the value onto the end of the string as it will be interpreted literally


Must convert this value to little-endian and then into a byte string.



From readelf:
win function hex address -> 080491f6
        in little-endian -> f6 91 04 08
        as a binary strings -> b'\xf6\x91\x04\08


thus our final string should be:
b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' + b'\xf6\x91\x04\08'



Now how to pipe this into client -> see attack.py




Most of the manipulation of bytes regarding to endian and parsing as a byte string comes from:

John Hammond -> https://www.youtube.com/watch?v=k4hqdVo3cqk&ab_channel=JohnHammond